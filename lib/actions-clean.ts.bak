'use server';

import { createClient } from '@/lib/supabase/server';
import { Profile, Story, Chapter } from './database.types';
import { RUNE_COSTS } from './types';
import { downloadAndStoreImage } from './storage';
import { type HeroRelationship } from './types';

// R√©-export du type Chapter
export type { Chapter };
export type { HeroRelationship };

const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY; // Gard√© pour fallback si besoin

export type ActionResponse<T> = {
  data: T | null;
  error: string | null;
};

export type GeneratedStory = {
  title: string;
  content: string;
  imageUrl: string;
  endingImageUrl?: string;
  storyId?: string;
};

export type ChildProfile = {
  id: string;
  first_name: string;
  age: number;
  avatar_url: string | null;
  created_at: string | null;
  traits: string[] | null;
};

// Types pour les histoires interactives
type InteractiveChapter = {
  chapterNumber: number;
  title: string;
  content: string;
  hasChoice: boolean;
  choice?: {
    question: string;
    optionA: { text: string; nextChapter: number };
    optionB: { text: string; nextChapter: number };
  };
  isEnding: boolean;
};

export type GeneratedInteractiveStory = {
  title: string;
  storyId: string;
  chapters: InteractiveChapter[];
  coverImageUrl: string;
};

/**
 * G√©n√®re une histoire avec Gemini 2.5 Flash et illustration Imagen 4
 */
export async function generateAndSaveStory(
  hero1Name: string,
  hero1Age: number,
  hero2Name: string | null,
  hero2Age: number | null,
  world: string,
  theme: string
): Promise<ActionResponse<GeneratedStory>> {
  try {
    const supabase = await createClient();
    
    // V√©rification des runes
    const canCreateResult = await canCreateStory('linear');
    if (canCreateResult.error || !canCreateResult.data?.canCreate) {
      return {
        data: null,
        error: `Tu n'as pas assez de runes !`,
      };
    }

    if (!GOOGLE_API_KEY) {
      return { data: null, error: 'Cl√© API Google non configur√©e.' };
    }

    // R√©cup√©rer le profil du h√©ros
    let profile1Id: string | null = null;
    let relationshipDescription = '';
    
    try {
      const { data: existingProfile1 } = await supabase
        .from('profiles')
        .select('id, traits')
        .eq('first_name', hero1Name)
        .order('created_at', { ascending: false })
        .limit(1)
        .maybeSingle();
      
      if (existingProfile1) {
        profile1Id = existingProfile1.id;
      }
      
      if (hero2Name) {
        const { data: existingProfile2 } = await supabase
          .from('profiles')
          .select('id')
          .eq('first_name', hero2Name)
          .order('created_at', { ascending: false })
          .limit(1)
          .maybeSingle();
        
        if (existingProfile2 && profile1Id) {
          const { data: rel } = await supabase
            .from('hero_relationships')
            .select('relation_type')
            .eq('from_hero_id', profile1Id)
            .eq('to_hero_id', existingProfile2.id)
            .maybeSingle();
          
          if (rel) {
            const relLabels: Record<string, string> = {
              'frere': 'fr√®re',
              'soeur': 's≈ìur',
              'frere_soeur': 'fr√®re/s≈ìur',
              'ami': 'meilleur ami',
              'cousin': 'cousin',
              'jumeau': 'jumeau',
              'voisin': 'voisin',
              'camarade': 'camarade',
            };
            relationshipDescription = `${hero1Name} est ${relLabels[rel.relation_type] || rel.relation_type} de ${hero2Name}`;
          }
        }
      }
    } catch (e) {
      console.log('‚ÑπÔ∏è Pas de relation trouv√©e:', e);
    }

    const hasTwoHeroes = !!hero2Name;
    const heroDescription = hasTwoHeroes 
      ? `DEUX H√âROS : ${hero1Name} (${hero1Age} ans) et ${hero2Name} (${hero2Age} ans). ${relationshipDescription || 'Ils sont amis et affrontent l\'aventure ensemble.'}`
      : `H√âROS : ${hero1Name}, un enfant courageux de ${hero1Age} ans.`;

    const avgAge = hasTwoHeroes ? Math.round((hero1Age + (hero2Age || hero1Age)) / 2) : hero1Age;

    // 1. G√©n√©rer le texte avec Gemini 2.5 Flash
    const prompt = `Tu es un auteur de contes pour enfants. √âcris une histoire magique en fran√ßais.

${heroDescription}
üåç UNIVERS : ${world}
üìñ TH√àME : ${theme}
üë∂ √ÇGE CIBLE : ${avgAge} ans

CONTRAINTES :
- Longueur : 800-1000 mots
- 3 ch√®nes/sc√®nes principales avec une transition "---" entre chaque
- Ton adapt√© √† ${avgAge} ans
- Le h√©ros r√©sout un probl√®me gr√¢ce √† ses qualit√©s
- Fin heureuse et morale positive

FORMAT DE SORTIE :
Commence par le titre sur une ligne : "Titre : [titre accrocheur]"
Puis l'histoire avec les s√©parateurs "---" entre les chapitres/sc√®nes.`;

    console.log('ü§ñ Appel Gemini 2.5 Flash...');
    
    const textResponse = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-01-21:generateContent?key=${GOOGLE_API_KEY}`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: {
            temperature: 0.8,
            maxOutputTokens: 2048,
          },
        }),
      }
    );

    if (!textResponse.ok) {
      const errorData = await textResponse.json().catch(() => ({}));
      console.error('‚ùå Erreur Gemini:', errorData);
      return { data: null, error: `Erreur API Gemini (${textResponse.status})` };
    }

    const textData = await textResponse.json();
    const generatedText = textData.candidates?.[0]?.content?.parts?.[0]?.text || '';
    
    // Parser le titre et le contenu
    const titleMatch = generatedText.match(/Titre\s*:\s*["']?([^"'\n]+)["']?/i);
    const title = titleMatch ? titleMatch[1].trim() : `L'aventure de ${hero1Name}`;
    const content = generatedText.replace(/Titre\s*:\s*["']?[^"'\n]+["']?\n*/i, '').trim();
    
    console.log('‚úÖ Histoire g√©n√©r√©e:', title);

    // 2. G√©n√©rer les images avec Imagen 4
    let imageUrl = '';
    let endingImageUrl = '';
    
    try {
      // Image de couverture
      const coverPrompt = `Children's book illustration, soft watercolor magical style: 
${hasTwoHeroes 
  ? `Two young heroes (${hero1Name} and ${hero2Name}) on an adventure in ${world}, ${theme.toLowerCase()} theme.` 
  : `A young child named ${hero1Name} on a magical adventure in ${world}, ${theme.toLowerCase()} theme.`}
Warm colors, dreamy atmosphere, storybook art style suitable for children age ${avgAge}.
No text, no words in the image.`;

      console.log('üé® Appel Imagen 4...');
      
      const imageResponse = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/imagen-4-fast:generateImage?key=${GOOGLE_API_KEY}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: coverPrompt,
            aspectRatio: '1:1',
          }),
        }
      );

      if (imageResponse.ok) {
        const imageData = await imageResponse.json();
        imageUrl = imageData.image?.url || '';
        console.log('‚úÖ Image couverture g√©n√©r√©e');
      }
      
      // Image de fin
      const endingPrompt = `Children's book illustration, soft watercolor magical style - FINAL SCENE:
${hasTwoHeroes 
  ? `Two young heroes (${hero1Name} and ${hero2Name}) at the end of their adventure in ${world}, showing joy and accomplishment.` 
  : `A young child named ${hero1Name} at the end of the adventure in ${world}, happy and accomplished.`}
Warm golden colors, satisfying conclusion, storybook art style suitable for children age ${avgAge}.
No text in the image.`;

      const endingResponse = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/imagen-4-fast:generateImage?key=${GOOGLE_API_KEY}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: endingPrompt,
            aspectRatio: '1:1',
          }),
        }
      );

      if (endingResponse.ok) {
        const endingData = await endingResponse.json();
        endingImageUrl = endingData.image?.url || '';
        console.log('‚úÖ Image fin g√©n√©r√©e');
      }
    } catch (imgErr) {
      console.error('‚ùå Erreur Imagen 4:', imgErr);
    }

    // 3. D√©biter les runes
    const spendResult = await spendRunesForStory('linear', title);
    if (spendResult.error) {
      return { data: null, error: `Erreur lors du paiement: ${spendResult.error}` };
    }

    // 4. Sauvegarder l'histoire
    const { data: story, error: storyError } = await supabase
      .from('stories')
      .insert([{ 
        profile_id: profile1Id, 
        title: title, 
        content: content, 
        theme: theme
      }])
      .select()
      .single();

    if (storyError || !story) {
      await refundRunes(RUNE_COSTS.LINEAR_STORY, 'error-save', 'Erreur sauvegarde');
      return { data: null, error: 'Erreur lors de la sauvegarde' };
    }

    const storyId = story.id;

    // 5. Stocker les images
    let storedImagePath = '';
    let storedEndingImagePath = '';
    
    if (imageUrl) {
      const coverResult = await downloadAndStoreImage(storyId, imageUrl, 'cover');
      if (!coverResult.error) storedImagePath = coverResult.storagePath;
    }
    
    if (endingImageUrl) {
      const endingResult = await downloadAndStoreImage(storyId, endingImageUrl, 'ending');
      if (!endingResult.error) storedEndingImagePath = endingResult.storagePath;
    }

    return {
      data: { 
        title, 
        content, 
        imageUrl: storedImagePath || imageUrl, 
        endingImageUrl: storedEndingImagePath || endingImageUrl, 
        storyId 
      },
      error: null,
    };
  } catch (err) {
    console.error('üí• Exception:', err);
    return {
      data: null,
      error: `Erreur technique: ${err instanceof Error ? err.message : 'Inconnue'}`,
    };
  }
}

// Fonction pour les histoires interactives avec Gemini
export async function generateAndSaveInteractiveStory(
  hero1Name: string,
  hero1Age: number,
  hero2Name: string | null,
  hero2Age: number | null,
  world: string,
  theme: string
): Promise<ActionResponse<GeneratedInteractiveStory>> {
  try {
    const supabase = await createClient();
    
    const canCreateResult = await canCreateStory('interactive');
    if (canCreateResult.error || !canCreateResult.data?.canCreate) {
      return {
        data: null,
        error: `Tu n'as pas assez de runes !`,
      };
    }

    if (!GOOGLE_API_KEY) {
      return { data: null, error: 'Cl√© API Google non configur√©e.' };
    }

    const hasTwoHeroes = !!hero2Name;
    
    // R√©cup√©rer le profil
    let profile1Id: string | null = null;
    try {
      const { data: profile1 } = await supabase
        .from('profiles')
        .select('id')
        .eq('first_name', hero1Name)
        .order('created_at', { ascending: false })
        .limit(1)
        .maybeSingle();
      
      if (profile1) profile1Id = profile1.id;
    } catch (e) {
      console.log('‚ÑπÔ∏è Pas de profil trouv√©:', e);
    }

    const avgAge = hasTwoHeroes ? Math.round((hero1Age + (hero2Age || hero1Age)) / 2) : hero1Age;
    
    const heroDescription = hasTwoHeroes 
      ? `DEUX H√âROS : ${hero1Name} (${hero1Age} ans) et ${hero2Name} (${hero2Age} ans).`
      : `H√âROS : ${hero1Name}, un enfant courageux de ${hero1Age} ans.`;

    // G√©n√©rer l'histoire interactive avec Gemini
    const interactivePrompt = `Tu es un auteur de contes interactifs pour enfants. √âcris une histoire DONT VOUS √äTES LE H√âROS.

${heroDescription}
üåç UNIVERS : ${world}
üìñ TH√àME : ${theme}
üë∂ √ÇGE CIBLE : ${avgAge} ans

STRUCTURE OBLIGATOIRE - 5 chapitres avec 2 choix :

**Chapitre 1** : Introduction (150-200 mots)
**Chapitre 2** : Premier obstacle + CHOIX 1 √† la fin (150-200 mots + choix)
**Chapitre 3A ou 3B** : Cons√©quence du choix (150-200 mots)
**Chapitre 4** : Nouveau d√©fi + CHOIX 2 √† la fin (150-200 mots + choix)
**Chapitre 5A ou 5B** : D√©nouement et fin (150-200 mots, isEnding: true)

FORMAT JSON STRICT :
{
  "title": "Titre accrocheur",
  "chapters": [
    {
      "chapterNumber": 1,
      "title": "Titre du chapitre",
      "content": "Texte...",
      "hasChoice": false,
      "isEnding": false
    },
    {
      "chapterNumber": 2,
      "title": "...",
      "content": "...",
      "hasChoice": true,
      "choice": {
        "question": "Que fais-tu ?",
        "optionA": { "text": "Option A", "nextChapter": 3 },
        "optionB": { "text": "Option B", "nextChapter": 4 }
      },
      "isEnding": false
    }
  ]
}

Retourne UNIQUEMENT le JSON valide.`;

    console.log('ü§ñ Appel Gemini 2.5 Flash (interactive)...');
    
    const textResponse = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-01-21:generateContent?key=${GOOGLE_API_KEY}`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: interactivePrompt }] }],
          generationConfig: {
            temperature: 0.8,
            maxOutputTokens: 4096,
          },
        }),
      }
    );

    if (!textResponse.ok) {
      const errorData = await textResponse.json().catch(() => ({}));
      console.error('‚ùå Erreur Gemini:', errorData);
      return { data: null, error: `Erreur API Gemini (${textResponse.status})` };
    }

    const textData = await textResponse.json();
    const storyContent = textData.candidates?.[0]?.content?.parts?.[0]?.text || '';
    
    // Parser le JSON
    let parsedStory;
    try {
      const jsonMatch = storyContent.match(/```json\s*([\s\S]*?)```/) || 
                        storyContent.match(/```\s*([\s\S]*?)```/) ||
                        [null, storyContent];
      const jsonString = jsonMatch[1].trim();
      parsedStory = JSON.parse(jsonString);
    } catch (parseErr) {
      console.error('‚ùå Erreur parsing JSON:', parseErr);
      return { data: null, error: 'Erreur lors du parsing de l\'histoire' };
    }

    const { title, chapters } = parsedStory;

    // G√©n√©rer l'image de couverture avec Imagen 4
    let coverImageUrl = '';
    try {
      const coverPrompt = `Children's book illustration: ${hasTwoHeroes 
        ? `Two young heroes (${hero1Name} and ${hero2Name}) on an adventure in ${world}.` 
        : `A young child named ${hero1Name} on a magical adventure in ${world}.`}
Watercolor storybook style, magical lighting, suitable for children age ${avgAge}. No text.`;

      const imageResponse = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/imagen-4-fast:generateImage?key=${GOOGLE_API_KEY}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: coverPrompt,
            aspectRatio: '1:1',
          }),
        }
      );

      if (imageResponse.ok) {
        const imageData = await imageResponse.json();
        coverImageUrl = imageData.image?.url || '';
      }
    } catch (imgErr) {
      console.error('‚ùå Erreur Imagen 4:', imgErr);
    }

    // D√©biter les runes
    const spendResult = await spendRunesForStory('interactive', title);
    if (spendResult.error) {
      return { data: null, error: `Erreur lors du paiement: ${spendResult.error}` };
    }

    // Sauvegarder l'histoire
    const { data: story, error: storyError } = await supabase
      .from('stories')
      .insert([{ 
        profile_id: profile1Id, 
        title: title, 
        content: `Histoire interactive avec ${chapters.length} chapitres.`, 
        theme: theme,
        story_type: 'interactive'
      }])
      .select()
      .single();

    if (storyError || !story) {
      await refundRunes(RUNE_COSTS.INTERACTIVE_STORY, 'error-save', 'Erreur sauvegarde');
      return { data: null, error: 'Erreur lors de la sauvegarde' };
    }

    const storyId = story.id;

    // Sauvegarder les chapitres
    const chaptersToInsert = chapters.map((ch: InteractiveChapter) => ({
      story_id: storyId,
      chapter_number: ch.chapterNumber,
      title: ch.title || `Chapitre ${ch.chapterNumber}`,
      content: ch.content,
      has_choice: ch.hasChoice,
      choice_question: ch.choice?.question || null,
      choice_option_a: ch.choice?.optionA?.text || null,
      choice_option_a_next_chapter: ch.choice?.optionA?.nextChapter || null,
      choice_option_b: ch.choice?.optionB?.text || null,
      choice_option_b_next_chapter: ch.choice?.optionB?.nextChapter || null,
      is_ending: ch.isEnding,
    }));

    await supabase.from('chapters').insert(chaptersToInsert);

    // Stocker l'image
    let storedCoverPath = '';
    if (coverImageUrl) {
      const coverResult = await downloadAndStoreImage(storyId, coverImageUrl, 'cover');
      if (!coverResult.error) storedCoverPath = coverResult.storagePath;
    }

    return {
      data: { 
        title, 
        storyId, 
        chapters,
        coverImageUrl: storedCoverPath || coverImageUrl 
      },
      error: null,
    };
  } catch (err) {
    console.error('üí• Exception:', err);
    return {
      data: null,
      error: `Erreur technique: ${err instanceof Error ? err.message : 'Inconnue'}`,
    };
  }
}

// Fonction pour g√©n√©rer un avatar avec Imagen 4
export async function generateChildAvatar(
  name: string,
  age: number,
  description?: string
): Promise<ActionResponse<{ avatarUrl: string }>> {
  try {
    if (!GOOGLE_API_KEY) {
      return { data: null, error: 'Cl√© API Google non configur√©e' };
    }

    const prompt = `Cute children's book character portrait illustration:
A ${age}-year-old child named ${name}.
${description || 'Friendly, adventurous look.'}
Soft watercolor style, warm colors, circular portrait format like a profile picture.
Simple background with magical sparkles.
No text, no words in the image.`;

    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/imagen-4-fast:generateImage?key=${GOOGLE_API_KEY}`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          aspectRatio: '1:1',
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return { data: null, error: `Erreur g√©n√©ration avatar (${response.status})` };
    }

    const data = await response.json();
    return { data: { avatarUrl: data.image?.url || '' }, error: null };
  } catch (err) {
    console.error('Error generating avatar:', err);
    return { data: null, error: 'Erreur lors de la g√©n√©ration' };
  }
}

